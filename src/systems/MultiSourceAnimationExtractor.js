import * as THREE from 'three'
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js'
import { DRACOLoader } from 'three/examples/jsm/loaders/DRACOLoader.js'

/**
 * Â§öÊ∫êÂä®ÁîªÊèêÂèñÂô®
 * ‰ªéCamera.glbÂíåScenes BÁ≥ªÂàóÊ®°Âûã‰∏≠ÊèêÂèñÂÆåÊï¥ÁöÑÂä®ÁîªÊï∞ÊçÆ
 */
export class MultiSourceAnimationExtractor {
  constructor() {
    this.isInitialized = false
    this.animationData = {
      v6Original: null,  // v6Ê®°ÂûãÁöÑÂéüÂßãÂä®Áîª
      camera: null,
      rings: {
        ring1: null, // Scenes_B_00100
        ring2: null, // Scenes_B_0023
        ring3: null  // Scenes_B_00100001
      }
    }
    this.totalDuration = 0
    this.phaseDurations = {
      phase1: 0,  // v6ÂéüÂßãÂä®Áîª
      phase2: 2,  // Áõ∏Êú∫ËøáÊ∏°Êó∂Èó¥
      phase3: 0   // Â§öÊ∫êÂä®ÁîªÁ≥ªÁªü
    }
    this.loader = new GLTFLoader()
    
    // ËÆæÁΩÆDRACOËß£Á†ÅÂô®
    const dracoLoader = new DRACOLoader()
    dracoLoader.setDecoderPath('https://www.gstatic.com/draco/versioned/decoders/1.5.6/')
    this.loader.setDRACOLoader(dracoLoader)
  }

  /**
   * ÂàùÂßãÂåñÂπ∂ÊèêÂèñÊâÄÊúâÂä®ÁîªÊï∞ÊçÆÔºà‰∏âÈò∂ÊÆµÁâàÊú¨Ôºâ
   */
  async initialize() {
    try {
      console.log('üé¨ Initializing Three-Phase Animation Extractor...')
      
      // Âπ∂Ë°åÊèêÂèñÊâÄÊúâÂä®ÁîªÊï∞ÊçÆ
      const [v6OriginalData, cameraData, ring1Data, ring2Data, ring3Data] = await Promise.all([
        this.extractV6OriginalAnimation(),
        this.extractCameraAnimation(),
        this.extractRingAnimation('ring1', '/Scenes_B_00100-transformed.glb', 'Scenes_B_00100'),
        this.extractRingAnimation('ring2', '/Scenes_B_0023-transformed.glb', 'Scenes_B_0023'),
        this.extractRingAnimation('ring3', '/Scenes_B_00100.001-transformed.glb', 'Scenes_B_00100001')
      ])

      this.animationData.v6Original = v6OriginalData
      this.animationData.camera = cameraData
      this.animationData.rings.ring1 = ring1Data
      this.animationData.rings.ring2 = ring2Data
      this.animationData.rings.ring3 = ring3Data

      // ËÆ°ÁÆó‰∏âÈò∂ÊÆµÊó∂Èïø
      this.calculateThreePhaseDuration()
      
      this.isInitialized = true
      this.logExtractionSummary()
      
      return this.animationData
      
    } catch (error) {
      console.error('‚ùå Failed to initialize Three-Phase Animation Extractor:', error)
      throw error
    }
  }

  /**
   * Âä†ËΩΩGLBÊñá‰ª∂
   */
  loadGLTF(url) {
    return new Promise((resolve, reject) => {
      this.loader.load(url, resolve, undefined, reject)
    })
  }

  /**
   * ÊèêÂèñv6Ê®°ÂûãÂéüÂßãÂä®ÁîªÊï∞ÊçÆ
   */
  async extractV6OriginalAnimation() {
    console.log('üéØ Extracting v6 original animation...')
    
    try {
      const gltf = await this.loadGLTF('/LOST_cut2_v6-transformed.glb')
      const { animations, scene } = gltf
      
      console.log(`üìä v6 model: ${animations.length} animations, scene children:`, scene.children.length)

      if (animations.length === 0) {
        console.warn('‚ö†Ô∏è No v6 original animations found in LOST_cut2_v6-transformed.glb')
        console.warn('   This will cause Phase 1 duration to be 0, leading to incorrect phase calculation')
        return null
      }

      const v6Animation = {
        rings: {
          ring1: { position: null, rotation: null, scale: null },
          ring2: { position: null, rotation: null, scale: null },
          ring3: { position: null, rotation: null, scale: null }
        },
        duration: 0,
        metadata: {
          animationCount: animations.length,
          tracks: []
        }
      }

      // Â§ÑÁêÜÊâÄÊúâÂä®Áîª
      animations.forEach((animation, index) => {
        console.log(`üé≠ Processing v6 animation ${index}: "${animation.name}" (${animation.duration}s)`)
        
        v6Animation.duration = Math.max(v6Animation.duration, animation.duration)

        animation.tracks.forEach(track => {
          const trackName = track.name
          const parts = trackName.split('.')
          const objectName = parts[0]
          const propertyName = parts[1]

          console.log(`  üìç v6 track: ${trackName}`)
          v6Animation.metadata.tracks.push(trackName)

          // Êò†Â∞Ñv6ÂØπË±°Âà∞ÁéØ
          if (objectName.includes('Á∂≤Ê†º003')) {
            // Ring 1
            if (propertyName === 'position') {
              v6Animation.rings.ring1.position = this.processTrack(track, 'position')
            } else if (propertyName === 'rotation' || propertyName === 'quaternion') {
              v6Animation.rings.ring1.rotation = this.processTrack(track, propertyName)
            } else if (propertyName === 'scale') {
              v6Animation.rings.ring1.scale = this.processTrack(track, 'scale')
            }
          } else if (objectName.includes('Á∂≤Ê†º002')) {
            // Ring 2
            if (propertyName === 'position') {
              v6Animation.rings.ring2.position = this.processTrack(track, 'position')
            } else if (propertyName === 'rotation' || propertyName === 'quaternion') {
              v6Animation.rings.ring2.rotation = this.processTrack(track, propertyName)
            } else if (propertyName === 'scale') {
              v6Animation.rings.ring2.scale = this.processTrack(track, 'scale')
            }
          } else if (objectName.includes('Á∂≤Ê†º001')) {
            // Ring 3
            if (propertyName === 'position') {
              v6Animation.rings.ring3.position = this.processTrack(track, 'position')
            } else if (propertyName === 'rotation' || propertyName === 'quaternion') {
              v6Animation.rings.ring3.rotation = this.processTrack(track, propertyName)
            } else if (propertyName === 'scale') {
              v6Animation.rings.ring3.scale = this.processTrack(track, 'scale')
            }
          }
        })
      })

      return v6Animation

    } catch (error) {
      console.error('‚ùå Failed to extract v6 original animation:', error)
      return null
    }
  }

  /**
   * ÊèêÂèñÁõ∏Êú∫Âä®ÁîªÊï∞ÊçÆ
   */
  async extractCameraAnimation() {
    console.log('üìπ Extracting camera animation from Camera.glb...')
    
    try {
      const gltf = await this.loadGLTF('/Camera-transformed.glb')
      const { animations, scene } = gltf
      
      console.log(`üìä Camera model: ${animations.length} animations, scene children:`, scene.children.length)

      if (animations.length === 0) {
        console.warn('‚ö†Ô∏è No camera animations found')
        return null
      }

      const cameraAnimation = {
        position: null,
        rotation: null,
        fov: null,
        duration: 0,
        metadata: {
          animationCount: animations.length,
          tracks: []
        }
      }

      // Â§ÑÁêÜÊâÄÊúâÂä®Áîª
      animations.forEach((animation, index) => {
        console.log(`üé≠ Processing camera animation ${index}: "${animation.name}" (${animation.duration}s)`)
        
        cameraAnimation.duration = Math.max(cameraAnimation.duration, animation.duration)

        animation.tracks.forEach(track => {
          const trackName = track.name
          const parts = trackName.split('.')
          const objectName = parts[0]
          const propertyName = parts[1]

          console.log(`  üìç Camera track: ${trackName}`)
          cameraAnimation.metadata.tracks.push(trackName)

          if (objectName === 'Camera') {
            switch (propertyName) {
              case 'position':
                cameraAnimation.position = this.processTrack(track, 'position')
                console.log(`    ‚úÖ Extracted camera position (${track.times.length} keyframes)`)
                break
              case 'rotation':
                cameraAnimation.rotation = this.processTrack(track, 'rotation')
                console.log(`    ‚úÖ Extracted camera rotation (${track.times.length} keyframes)`)
                break
              case 'quaternion':
                cameraAnimation.rotation = this.processTrack(track, 'quaternion')
                console.log(`    ‚úÖ Extracted camera quaternion (${track.times.length} keyframes)`)
                break
              case 'fov':
                cameraAnimation.fov = this.processTrack(track, 'fov')
                console.log(`    ‚úÖ Extracted camera FOV (${track.times.length} keyframes)`)
                break
            }
          }
        })
      })

      return cameraAnimation

    } catch (error) {
      console.error('‚ùå Failed to extract camera animation:', error)
      return null
    }
  }

  /**
   * ÊèêÂèñÁéØÂä®ÁîªÊï∞ÊçÆ
   */
  async extractRingAnimation(ringId, modelPath, objectName) {
    console.log(`üéØ Extracting ${ringId} animation from ${modelPath}...`)
    
    try {
      const gltf = await this.loadGLTF(modelPath)
      const { animations, scene } = gltf
      
      console.log(`üìä ${ringId} model: ${animations.length} animations, scene children:`, scene.children.length)

      if (animations.length === 0) {
        console.warn(`‚ö†Ô∏è No animations found for ${ringId}`)
        return null
      }

      const ringAnimation = {
        position: null,
        rotation: null,
        scale: null,
        duration: 0,
        metadata: {
          objectName,
          modelPath,
          animationCount: animations.length,
          tracks: []
        }
      }

      // Â§ÑÁêÜÊâÄÊúâÂä®Áîª
      animations.forEach((animation, index) => {
        console.log(`üé≠ Processing ${ringId} animation ${index}: "${animation.name}" (${animation.duration}s)`)
        
        ringAnimation.duration = Math.max(ringAnimation.duration, animation.duration)

        animation.tracks.forEach(track => {
          const trackName = track.name
          const parts = trackName.split('.')
          const trackObjectName = parts[0]
          const propertyName = parts[1]

          if (trackObjectName === objectName) {
            console.log(`  üìç ${ringId} track: ${trackName}`)
            ringAnimation.metadata.tracks.push(trackName)

            switch (propertyName) {
              case 'position':
                ringAnimation.position = this.processTrack(track, 'position')
                console.log(`    ‚úÖ Extracted ${ringId} position (${track.times.length} keyframes)`)
                break
              case 'rotation':
                ringAnimation.rotation = this.processTrack(track, 'rotation')
                console.log(`    ‚úÖ Extracted ${ringId} rotation (${track.times.length} keyframes)`)
                break
              case 'quaternion':
                ringAnimation.rotation = this.processTrack(track, 'quaternion')
                console.log(`    ‚úÖ Extracted ${ringId} quaternion (${track.times.length} keyframes)`)
                break
              case 'scale':
                ringAnimation.scale = this.processTrack(track, 'scale')
                console.log(`    ‚úÖ Extracted ${ringId} scale (${track.times.length} keyframes)`)
                break
            }
          }
        })
      })

      return ringAnimation

    } catch (error) {
      console.error(`‚ùå Failed to extract ${ringId} animation:`, error)
      return null
    }
  }

  /**
   * Â§ÑÁêÜÂä®ÁîªËΩ®ÈÅìÊï∞ÊçÆ
   */
  processTrack(track, propertyType) {
    const processedTrack = {
      times: Array.from(track.times),
      values: Array.from(track.values),
      keyframes: [],
      interpolation: track.getInterpolation ? track.getInterpolation() : 'LINEAR',
      type: propertyType
    }

    // Ê†πÊçÆÂ±ûÊÄßÁ±ªÂûãÂ§ÑÁêÜÊï∞ÊçÆ
    switch (propertyType) {
      case 'position':
      case 'scale':
        for (let i = 0; i < track.values.length; i += 3) {
          processedTrack.keyframes.push({
            x: track.values[i],
            y: track.values[i + 1],
            z: track.values[i + 2]
          })
        }
        break

      case 'rotation':
        for (let i = 0; i < track.values.length; i += 3) {
          processedTrack.keyframes.push({
            x: track.values[i],
            y: track.values[i + 1],
            z: track.values[i + 2]
          })
        }
        break

      case 'quaternion':
        processedTrack.type = 'quaternion'
        for (let i = 0; i < track.values.length; i += 4) {
          processedTrack.keyframes.push({
            x: track.values[i],
            y: track.values[i + 1],
            z: track.values[i + 2],
            w: track.values[i + 3]
          })
        }
        break

      case 'fov':
        for (let i = 0; i < track.values.length; i++) {
          processedTrack.keyframes.push({
            value: track.values[i]
          })
        }
        break
    }

    return processedTrack
  }

  /**
   * ËÆ°ÁÆó‰∏âÈò∂ÊÆµÂä®ÁîªÊó∂Èïø
   */
  calculateThreePhaseDuration() {
    // Phase 1: v6ÂéüÂßãÂä®Áîª
    if (this.animationData.v6Original && this.animationData.v6Original.duration > 0) {
      this.phaseDurations.phase1 = this.animationData.v6Original.duration
      console.log(`‚úÖ Phase 1 duration from v6Original: ${this.phaseDurations.phase1}s`)
    } else {
      // Â¶ÇÊûúv6OriginalÊ≤°ÊúâÂä†ËΩΩÊàñÊó∂Èïø‰∏∫0ÔºåËÆæÁΩÆ‰∏Ä‰∏™ÈªòËÆ§ÁöÑPhase 1Êó∂Èïø
      this.phaseDurations.phase1 = 7.0
      console.warn('‚ö†Ô∏è v6Original not loaded or duration is 0, using default Phase 1 duration: 7.0s')
    }

    // Phase 2: Áõ∏Êú∫ËøáÊ∏°ÔºàÂõ∫ÂÆö2ÁßíÔºâ
    this.phaseDurations.phase2 = 2.0

    // Phase 3: Â§öÊ∫êÂä®ÁîªÁ≥ªÁªü
    let phase3Duration = 0
    if (this.animationData.camera) {
      phase3Duration = Math.max(phase3Duration, this.animationData.camera.duration)
    }
    Object.values(this.animationData.rings).forEach(ringData => {
      if (ringData) {
        phase3Duration = Math.max(phase3Duration, ringData.duration)
      }
    })
    this.phaseDurations.phase3 = phase3Duration

    // ÊÄªÊó∂Èïø
    this.totalDuration = this.phaseDurations.phase1 + this.phaseDurations.phase2 + this.phaseDurations.phase3

    console.log(`‚è±Ô∏è Three-Phase Animation Duration:`)
    console.log(`  Phase 1 (v6 Original): ${this.phaseDurations.phase1.toFixed(2)}s`)
    console.log(`  Phase 2 (Camera Transition): ${this.phaseDurations.phase2.toFixed(2)}s`)
    console.log(`  Phase 3 (Multi-Source): ${this.phaseDurations.phase3.toFixed(2)}s`)
    console.log(`  Total Duration: ${this.totalDuration.toFixed(2)}s`)
  }

  /**
   * Ëé∑ÂèñÂΩìÂâçÊó∂Èó¥ÂØπÂ∫îÁöÑÂä®ÁîªÈò∂ÊÆµ
   */
  getCurrentPhase(time) {
    
    if (time <= this.phaseDurations.phase1) {
      return {
        phase: 1,
        phaseTime: time,
        progress: time / this.phaseDurations.phase1
      }
    } else if (time <= this.phaseDurations.phase1 + this.phaseDurations.phase2) {
      const phaseStartTime = this.phaseDurations.phase1
      const phaseTime = time - phaseStartTime
      return {
        phase: 2,
        phaseTime: phaseTime,
        progress: phaseTime / this.phaseDurations.phase2
      }
    } else {
      const phaseStartTime = this.phaseDurations.phase1 + this.phaseDurations.phase2
      const phaseTime = time - phaseStartTime
      return {
        phase: 3,
        phaseTime: phaseTime,
        progress: phaseTime / this.phaseDurations.phase3
      }
    }
  }

  /**
   * Ëé∑Âèñv6ÂéüÂßãÂä®ÁîªÂú®ÊåáÂÆöÊó∂Èó¥ÁöÑÁéØÂèòÊç¢
   */
  getV6OriginalRingTransformAtTime(ringId, time) {
    if (!this.animationData.v6Original) return null

    const ringMap = {
      'ring1': 'ring1',
      'ring2': 'ring2', 
      'ring3': 'ring3'
    }

    const ringData = this.animationData.v6Original.rings[ringMap[ringId]]
    if (!ringData) return null

    const normalizedTime = time % this.animationData.v6Original.duration

    const result = {
      position: { x: 0, y: 0, z: 0 },
      rotation: { x: 0, y: 0, z: 0 },
      scale: { x: 1, y: 1, z: 1 }
    }

    if (ringData.position) {
      result.position = this.interpolateProperty(ringData.position, normalizedTime, 3)
    }

    if (ringData.rotation) {
      const componentCount = ringData.rotation.type === 'quaternion' ? 4 : 3
      result.rotation = this.interpolateProperty(ringData.rotation, normalizedTime, componentCount)
    }

    if (ringData.scale) {
      result.scale = this.interpolateProperty(ringData.scale, normalizedTime, 3)
    }

    return result
  }

  /**
   * ËÆ°ÁÆó‰ªé‰∏Ä‰∏™‰ΩçÁΩÆÁúãÂêëÂè¶‰∏Ä‰∏™‰ΩçÁΩÆÁöÑÊóãËΩ¨ËßíÂ∫¶
   */
  calculateLookAtRotation(fromPosition, toPosition) {
    const from = new THREE.Vector3(fromPosition.x, fromPosition.y, fromPosition.z)
    const to = new THREE.Vector3(toPosition.x, toPosition.y, toPosition.z)
    
    // ËÆ°ÁÆóÊñπÂêëÂêëÈáè
    const direction = to.clone().sub(from).normalize()
    
    // ÂàõÂª∫lookAtÁü©Èòµ
    const matrix = new THREE.Matrix4()
    const up = new THREE.Vector3(0, 1, 0)
    matrix.lookAt(from, to, up)
    
    // ‰ªéÁü©ÈòµÊèêÂèñÊóãËΩ¨
    const euler = new THREE.Euler()
    euler.setFromRotationMatrix(matrix)
    
    return { x: euler.x, y: euler.y, z: euler.z }
  }

  /**
   * Âú®ÊåáÂÆöÊó∂Èó¥Ëé∑ÂèñÁõ∏Êú∫ÂèòÊç¢Ôºà‰∏âÈò∂ÊÆµÁâàÊú¨Ôºâ
   */
  getCameraTransformAtTime(time) {
    const currentPhase = this.getCurrentPhase(time)
    
    // ÂÆö‰πâÈùôÊÄÅÁõ∏Êú∫‰ΩçÁΩÆÔºàÁî®‰∫éPhase 1Ôºâ- ‰ΩøÁî®Áî®Êà∑‰øùÂ≠òÁöÑÁêÜÊÉ≥ËßÜËßí
    const staticCameraParams = {
      position: { x: -18.43, y: 14.48, z: 16.30 },  // Áî®Êà∑ÂÆö‰πâÁöÑÁêÜÊÉ≥‰ΩçÁΩÆ
      rotation: this.calculateLookAtRotation(
        { x: -18.43, y: 14.48, z: 16.30 },  // Áõ∏Êú∫‰ΩçÁΩÆ
        { x: -1.40, y: 15.30, z: -1.33 }    // Áî®Êà∑‰øùÂ≠òÁöÑÂéüÂßãÁõÆÊ†á‰ΩçÁΩÆ
      ),
      fov: 35.0  // Áî®Êà∑‰øùÂ≠òÁöÑÂéüÂßãFOV
    }

    // ÈªòËÆ§Áõ∏Êú∫ÂèÇÊï∞ÔºàCamera.glbÁöÑËµ∑Âßã‰ΩçÁΩÆÔºâ
    const defaultCameraParams = {
      position: { x: 13.037, y: 2.624, z: 23.379 },
      rotation: { x: 0.318, y: 0.562, z: -0.051 },
      fov: 25.361
    }

    switch (currentPhase.phase) {
      case 1:
        // Phase 1: ÈùôÊÄÅÁõ∏Êú∫
        return staticCameraParams

      case 2:
        // Phase 2: Áõ∏Êú∫ËøáÊ∏°Ôºà‰ªéÁî®Êà∑Ëá™ÂÆö‰πâ‰ΩçÁΩÆÂà∞Camera.glbËµ∑Âßã‰ΩçÁΩÆÔºâ
        const progress = currentPhase.progress
        const easeInOutCubic = (t) => {
          return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2
        }
        const smoothProgress = easeInOutCubic(progress)

        // ËÆ°ÁÆó‰ªéÁî®Êà∑‰ΩçÁΩÆÁúãÂêëÁõÆÊ†áÁöÑÊóãËΩ¨ËßíÂ∫¶
        const userTargetVector = new THREE.Vector3(-1.40, 15.30, -1.33)
        const userPositionVector = new THREE.Vector3(-18.43, 14.48, 16.30)
        const lookDirection = userTargetVector.clone().sub(userPositionVector).normalize()
        
        // ËÆ°ÁÆóÁî®Êà∑ËßÜËßíÁöÑÊ¨ßÊãâËßí
        const userEuler = new THREE.Euler()
        userEuler.setFromQuaternion(new THREE.Quaternion().setFromUnitVectors(
          new THREE.Vector3(0, 0, -1), 
          lookDirection
        ))

        return {
          position: {
            x: staticCameraParams.position.x + (defaultCameraParams.position.x - staticCameraParams.position.x) * smoothProgress,
            y: staticCameraParams.position.y + (defaultCameraParams.position.y - staticCameraParams.position.y) * smoothProgress,
            z: staticCameraParams.position.z + (defaultCameraParams.position.z - staticCameraParams.position.z) * smoothProgress
          },
          rotation: {
            x: userEuler.x + (defaultCameraParams.rotation.x - userEuler.x) * smoothProgress,
            y: userEuler.y + (defaultCameraParams.rotation.y - userEuler.y) * smoothProgress,
            z: userEuler.z + (defaultCameraParams.rotation.z - userEuler.z) * smoothProgress
          },
          fov: staticCameraParams.fov + (defaultCameraParams.fov - staticCameraParams.fov) * smoothProgress
        }

      case 3:
        // Phase 3: Camera.glbÂä®Áîª
        if (!this.animationData.camera) return defaultCameraParams

        const normalizedTime = currentPhase.phaseTime % this.animationData.camera.duration
        const result = { ...defaultCameraParams }

        if (this.animationData.camera.position) {
          result.position = this.interpolateProperty(this.animationData.camera.position, normalizedTime, 3)
        }

        if (this.animationData.camera.rotation) {
          const componentCount = this.animationData.camera.rotation.type === 'quaternion' ? 4 : 3
          result.rotation = this.interpolateProperty(this.animationData.camera.rotation, normalizedTime, componentCount)
        }

        if (this.animationData.camera.fov) {
          result.fov = this.interpolateProperty(this.animationData.camera.fov, normalizedTime, 1).value || 25.361
        }

        return result

      default:
        return defaultCameraParams
    }
  }

  /**
   * Âú®ÊåáÂÆöÊó∂Èó¥Ëé∑ÂèñÁéØÂèòÊç¢Ôºà‰∏âÈò∂ÊÆµÁâàÊú¨Ôºâ
   */
  getRingTransformAtTime(ringId, time) {
    const currentPhase = this.getCurrentPhase(time)

    switch (currentPhase.phase) {
      case 1:
        // Phase 1: ‰ΩøÁî®v6ÂéüÂßãÂä®Áîª
        return this.getV6OriginalRingTransformAtTime(ringId, currentPhase.phaseTime)

      case 2:
        // Phase 2: Áõ∏Êú∫ËøáÊ∏°ÊúüÈó¥ÔºåÁéØ‰øùÊåÅv6Âä®ÁîªÁöÑÊúÄÂêéÁä∂ÊÄÅ
        const v6Duration = this.animationData.v6Original?.duration || 0
        return this.getV6OriginalRingTransformAtTime(ringId, v6Duration)

      case 3:
        // Phase 3: ‰ΩøÁî®Scenes BÂä®ÁîªÊï∞ÊçÆ
        const ringData = this.animationData.rings[ringId]
        if (!ringData) return null

        const normalizedTime = currentPhase.phaseTime % ringData.duration
        const result = {
          position: { x: 0, y: 0, z: 0 },
          rotation: { x: 0, y: 0, z: 0 },
          scale: { x: 1, y: 1, z: 1 }
        }

        if (ringData.position) {
          result.position = this.interpolateProperty(ringData.position, normalizedTime, 3)
        }

        if (ringData.rotation) {
          const componentCount = ringData.rotation.type === 'quaternion' ? 4 : 3
          result.rotation = this.interpolateProperty(ringData.rotation, normalizedTime, componentCount)
        }

        if (ringData.scale) {
          result.scale = this.interpolateProperty(ringData.scale, normalizedTime, 3)
        }

        return result

      default:
        return {
          position: { x: 0, y: 0, z: 0 },
          rotation: { x: 0, y: 0, z: 0 },
          scale: { x: 1, y: 1, z: 1 }
        }
    }
  }

  /**
   * Â±ûÊÄßÊèíÂÄºËÆ°ÁÆó
   */
  interpolateProperty(track, time, componentCount) {
    const { times, values } = track
    
    if (times.length === 0) {
      if (componentCount === 4) return { x: 0, y: 0, z: 0, w: 1 }
      if (componentCount === 1) return { value: 0 }
      return { x: 0, y: 0, z: 0 }
    }

    // Êü•ÊâæÊó∂Èó¥Âå∫Èó¥
    let index = 0
    for (let i = 0; i < times.length - 1; i++) {
      if (time >= times[i] && time <= times[i + 1]) {
        index = i
        break
      }
    }

    // ËæπÁïåÂ§ÑÁêÜ
    if (time <= times[0]) index = 0
    if (time >= times[times.length - 1]) index = times.length - 1

    // Â¶ÇÊûúÂú®ÊúÄÂêé‰∏Ä‰∏™ÂÖ≥ÈîÆÂ∏ß
    if (index === times.length - 1 || times.length === 1) {
      const startIndex = index * componentCount
      if (componentCount === 4) {
        return {
          x: values[startIndex],
          y: values[startIndex + 1],
          z: values[startIndex + 2],
          w: values[startIndex + 3]
        }
      } else if (componentCount === 1) {
        return { value: values[startIndex] }
      } else {
        return {
          x: values[startIndex],
          y: values[startIndex + 1],
          z: values[startIndex + 2]
        }
      }
    }

    // Á∫øÊÄßÊèíÂÄº
    const t1 = times[index]
    const t2 = times[index + 1]
    const factor = (time - t1) / (t2 - t1)

    const startIndex = index * componentCount
    const endIndex = (index + 1) * componentCount

    if (componentCount === 4) {
      // ÂõõÂÖÉÊï∞ÊèíÂÄº
      const q1 = new THREE.Quaternion(
        values[startIndex], values[startIndex + 1], 
        values[startIndex + 2], values[startIndex + 3]
      )
      const q2 = new THREE.Quaternion(
        values[endIndex], values[endIndex + 1],
        values[endIndex + 2], values[endIndex + 3]
      )
      
      const result = new THREE.Quaternion().slerpQuaternions(q1, q2, factor)
      return { x: result.x, y: result.y, z: result.z, w: result.w }
    } else if (componentCount === 1) {
      return {
        value: values[startIndex] + (values[endIndex] - values[startIndex]) * factor
      }
    } else {
      return {
        x: values[startIndex] + (values[endIndex] - values[startIndex]) * factor,
        y: values[startIndex + 1] + (values[endIndex + 1] - values[startIndex + 1]) * factor,
        z: values[startIndex + 2] + (values[endIndex + 2] - values[startIndex + 2]) * factor
      }
    }
  }

  /**
   * Ëé∑ÂèñÊâÄÊúâÂèòÊç¢Êï∞ÊçÆÔºà‰∏âÈò∂ÊÆµÁâàÊú¨Ôºâ
   */
  getAllTransformsAtTime(time) {
    const currentPhase = this.getCurrentPhase(time)
    
    return {
      phase: currentPhase,
      camera: this.getCameraTransformAtTime(time),
      rings: {
        ring1: this.getRingTransformAtTime('ring1', time),
        ring2: this.getRingTransformAtTime('ring2', time),
        ring3: this.getRingTransformAtTime('ring3', time)
      }
    }
  }

  /**
   * Ëé∑ÂèñÈò∂ÊÆµÊåÅÁª≠Êó∂Èó¥‰ø°ÊÅØ
   */
  getPhaseDurations() {
    return { ...this.phaseDurations }
  }

  /**
   * ËæìÂá∫ÊèêÂèñÊëòË¶ÅÔºà‰∏âÈò∂ÊÆµÁâàÊú¨Ôºâ
   */
  logExtractionSummary() {
    console.group('üìä Three-Phase Animation Extraction Summary')
    
    // v6ÂéüÂßãÂä®ÁîªÊëòË¶Å
    if (this.animationData.v6Original) {
      console.log('üéØ v6 Original Animation:')
      console.log(`  ‚è±Ô∏è Duration: ${this.animationData.v6Original.duration.toFixed(2)}s`)
      console.log(`  üìã Tracks: ${this.animationData.v6Original.metadata.tracks.length}`)
      console.log(`  üé® Ring 1: ${this.animationData.v6Original.rings.ring1.position ? '‚úÖ' : '‚ùå'}`)
      console.log(`  üé® Ring 2: ${this.animationData.v6Original.rings.ring2.position ? '‚úÖ' : '‚ùå'}`)
      console.log(`  üé® Ring 3: ${this.animationData.v6Original.rings.ring3.position ? '‚úÖ' : '‚ùå'}`)
    } else {
      console.log('üéØ v6 Original Animation: ‚ùå Not available')
    }
    
    // Áõ∏Êú∫Âä®ÁîªÊëòË¶Å
    if (this.animationData.camera) {
      console.log('\nüìπ Camera Animation:')
      console.log(`  ‚è±Ô∏è Duration: ${this.animationData.camera.duration.toFixed(2)}s`)
      console.log(`  üìç Position: ${this.animationData.camera.position ? '‚úÖ' : '‚ùå'}`)
      console.log(`  üîÑ Rotation: ${this.animationData.camera.rotation ? '‚úÖ' : '‚ùå'}`)
      console.log(`  üîç FOV: ${this.animationData.camera.fov ? '‚úÖ' : '‚ùå'}`)
      console.log(`  üìã Tracks: ${this.animationData.camera.metadata.tracks.length}`)
    } else {
      console.log('\nüìπ Camera Animation: ‚ùå Not available')
    }

    // Scenes BÁéØÂä®ÁîªÊëòË¶Å
    console.log('\nüéØ Scenes B Ring Animations:')
    Object.entries(this.animationData.rings).forEach(([ringId, data]) => {
      if (data) {
        console.log(`  ${ringId} (${data.metadata.objectName}):`)
        console.log(`    ‚è±Ô∏è Duration: ${data.duration.toFixed(2)}s`)
        console.log(`    üìç Position: ${data.position ? '‚úÖ' : '‚ùå'}`)
        console.log(`    üîÑ Rotation: ${data.rotation ? '‚úÖ' : '‚ùå'}`)
        console.log(`    üìè Scale: ${data.scale ? '‚úÖ' : '‚ùå'}`)
        console.log(`    üìã Tracks: ${data.metadata.tracks.length}`)
      } else {
        console.log(`  ${ringId}: ‚ùå Not available`)
      }
    })

    console.log(`\nüïê Phase Durations:`)
    console.log(`  Phase 1 (v6 Original): ${this.phaseDurations.phase1.toFixed(2)}s`)
    console.log(`  Phase 2 (Camera Transition): ${this.phaseDurations.phase2.toFixed(2)}s`)
    console.log(`  Phase 3 (Multi-Source): ${this.phaseDurations.phase3.toFixed(2)}s`)
    console.log(`üïê Total Duration: ${this.totalDuration.toFixed(2)}s`)
    console.log(`üé¨ System Status: ${this.isInitialized ? '‚úÖ Ready' : '‚ùå Not Ready'}`)
    
    console.groupEnd()
  }

  /**
   * Ëé∑ÂèñÂä®ÁîªÊåÅÁª≠Êó∂Èó¥
   */
  getDuration() {
    return this.totalDuration
  }

  /**
   * Ê£ÄÊü•ÊòØÂê¶ÂáÜÂ§áÂ∞±Áª™
   */
  isReady() {
    return this.isInitialized
  }
}

/**
 * ÂÖ®Â±ÄÂ§öÊ∫êÂä®ÁîªÊèêÂèñÂô®ÂÆû‰æã
 */
export const multiSourceAnimationExtractor = new MultiSourceAnimationExtractor()